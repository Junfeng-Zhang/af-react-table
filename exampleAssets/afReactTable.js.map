{"version":3,"sources":["webpack:///./src/Context/index.js","webpack:///./src/useApi/index.js","webpack:///./src/TableBody/Table/Colgroup/index.js","webpack:///./src/TableBody/Table/Rows/index.js","webpack:///./src/TableBody/Table/index.js","webpack:///./src/TableBody/index.js","webpack:///./src/TableHead/Colgroup/index.js","webpack:///./src/TableHead/index.js","webpack:///./src/utils/areArraysEqual/index.js","webpack:///./src/utils/addSetters/index.js","webpack:///./src/models/Basic/treeUtils/index.js","webpack:///./src/models/Basic/index.js","webpack:///./src/models/Table/index.js","webpack:///./src/utils/classNames/index.js","webpack:///./src/defaultComponents/Row/index.js","webpack:///./src/defaultComponents/Cell/index.js","webpack:///./src/defaultComponents/RowCountWarningContainer/index.js","webpack:///./src/index.js"],"names":["React","createContext","emptyArr","reducer","x","useApiPlugin","subscribeEvents","API","useContext","Context","ApiEvents","up","useReducer","useLayoutEffect","e","on","off","useApiPluginRaw","Events","SUBSCRIBE_EVENTS","memo","columns","map","dataKey","background","visibility","border","width","key","style","Rows","getRowData","getRowKey","getRowExtraProps","RowComponent","CellComponent","useEffect","reportRowsRendered","rangeFrom","rangeTo","rowKey","result","push","rowIndex","getVisibleRows","startIndex","endIndex","CachedColgroup","Table","tbodyRef","fixedLayout","virtualTopOffset","totalRows","tableStyle","transform","tableLayout","undefined","className","aria-rowcount","ref","TableBody","scrollContainerRef","useResizeObserver","height","setWidgetHeight","setWidgetWidth","scrollHandler","useCallback","target","scrollTop","scrollLeft","setScrollTop","setScrollLeft","scrollWrapperStyle","heightProviderStyle","pointerEvents","isScrolling","widgetScrollHeight","maxHeight","tabIndex","onScroll","TableHead","tbodyColumnWidths","right","column","j","cols","length","minWidth","maxWidth","title","label","areArraysEqual","one","two","addSetters","setters","varName","setterName","camelCase","eventName","kebabCase","newValue","prevValue","this","emit","walkUntil","dist","tree","v","N","nodeIndex","sum","l","r","res","calculateAllParents","i","getTreeContainer","elementsQuantity","Math","ceil","log2","Uint32Array","Base","params","EventEmitter","overscanRowsDistance","estimatedRowHeight","widgetHeight","widgetWidth","heighsCache","updatedNodesSet","Set","setIsScrollingFalseDebounced","debounce","setInitialScrollingEvents","setVisibleRowsHeights","throttle","pos","value","node","getRowsContainerNode","children","child","newHeight","offsetHeight","process","index","getAttribute","tmpPos","add","size","posSet","curSum","calculateParentsAt","clear","updateWidgetScrollHeight","increaseEndIndexIfNeeded","currentVisibleDist","updateEndIndex","getScrollContainerNode","refreshHeightsCache","setEstimatedRowHeight","setOverscanRowsDistance","setTotalRows","once","setIsScrollingTrue","setWidgetScrollHeight","cancelPendingAsyncCalls","cancel","refreshOffsets","max","newStartIndex","remainder","setVirtualTopOffset","setStartIndex","newEndIndex","setEndIndex","min","toggleBasicEvents","method","prevTotalRows","defaultValue","prevEndIndex","newTree","newN","idx","fill","reallocateIfNeeded","destructor","removeAllListeners","scrollToRow","clamp","prototype","calculateTbodyColumnWidths","tds","pixelWidths","td","offsetWidth","classNames","arg","len","arguments","Row","rowData","extraProps","aria-rowindex","propTypes","PropTypes","array","isRequired","oneOfType","func","number","Cell","transformCellData","getEmptyCellData","cellData","object","RowCountWarningContainer","props","createRef","Data","VirtualTableDataStore","rowCount","current","componentDidUpdate","setColumns","componentWillUnmount","render","rowCountWarningsTable","Provider","cn","PureComponent","HeaderRowComponent","any","bool","defaultProps","RowComponentDefault","CellComponentDefault","RowCountWarningContainerDefault"],"mappings":"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","file":"afReactTable.js","sourcesContent":["import React from \"react\";\n\nexport default React.createContext();","import { useContext, useLayoutEffect, useReducer } from \"react\";\nimport Context from \"../Context\";\n\nconst emptyArr = [];\n\nconst reducer = x => x + 1;\n\n/*\n\tTODO:\n\t\twhy useEffect does not properly update colgroup of tbody, when rowcount changes from 0 to positive value?\n*/\n\nconst useApiPluginRaw = ( ApiEvents, subscribeEvents) => {\n\n    const [, up] = useReducer( reducer, 0 );\n    \n\tuseLayoutEffect(() => {\n\t\tfor (let e of subscribeEvents) {\n\t\t\tApiEvents.on(e, up);\n\t\t}\n\t\treturn () => {\n\t\t\tfor (let e of subscribeEvents) {\n\t\t\t\tApiEvents.off(e, up);\n\t\t\t}\n\t\t};\n\t}, emptyArr );\n};\n\nexport const useApiContext = () => useContext( Context );\n\nexport const useApiPlugin = subscribeEvents => {\n\tconst API = useApiContext();\n    useApiPluginRaw( API.Events, subscribeEvents );\n    return API;\n};\n","import React, { memo } from \"react\";\nimport { useApiPlugin } from \"../../../useApi\";\n\nconst SUBSCRIBE_EVENTS = [\n    \"columns-changed\"\n];\n\nconst Colgroup = () => {\n    const { columns } = useApiPlugin( SUBSCRIBE_EVENTS );\n    return (\n        <colgroup>\n            {columns.map(({ dataKey, background, visibility, border, width }) => visibility !== \"hidden\" ? (\n                <col\n                    key={dataKey}\n                    style={{\n                        width,\n                        background,\n                        border\n                    }}\n                />\n            ) : null )}\n        </colgroup>\n    );\n};\n\nexport default memo( Colgroup );","import React, { memo, useEffect } from \"react\";\nimport { useApiPlugin } from \"../../../useApi\";\n\nconst SUBSCRIBE_EVENTS = [\n    \"start-index-changed\",\n    \"end-index-changed\",\n    \"columns-changed\"\n];\n\n\nconst getVisibleRows = (\n    rangeFrom,\n    rangeTo,\n    columns,\n    getRowData,\n    getRowKey,\n    getRowExtraProps,\n    RowComponent,\n    CellComponent\n) => {\n    const result = [];\n    for( let rowKey; rangeFrom < rangeTo; rangeFrom++ ){\n        rowKey = getRowKey ? getRowKey( rangeFrom ) : rangeFrom;\n        result.push(\n            <RowComponent\n                getRowExtraProps={getRowExtraProps}\n                rowIndex={rangeFrom}\n                key={rowKey}\n                columns={columns}\n                getRowData={getRowData}\n                CellComponent={CellComponent}\n            />\n        );\n    }\n    return result;\n};\n\nconst Rows = memo(({ getRowData, getRowKey, getRowExtraProps, RowComponent, CellComponent }) => {\n\n    const API = useApiPlugin( SUBSCRIBE_EVENTS );\n\n    useEffect(() => {\n        API.reportRowsRendered();\n    });\n\n    return getVisibleRows(\n        API.startIndex,\n        API.endIndex,\n        API.columns,\n        getRowData,\n        getRowKey,\n        getRowExtraProps,\n        RowComponent,\n        CellComponent\n    );\n});\n\nexport default Rows;","import React, { memo } from \"react\";\nimport Colgroup from \"./Colgroup\";\nimport Rows from \"./Rows\";\nimport { useApiPlugin } from \"../../useApi\";\n\nconst SUBSCRIBE_EVENTS = [\n    \"virtual-top-offset-changed\",\n    \"total-rows-changed\"\n];\n\nconst CachedColgroup = <Colgroup />;\n\nconst Table = memo(({\n    getRowData,\n    getRowKey,\n    getRowExtraProps,\n    tbodyRef,\n    RowComponent,\n    CellComponent,\n    fixedLayout\n}) => {\n    const { virtualTopOffset, totalRows } = useApiPlugin( SUBSCRIBE_EVENTS );\n\n\n    /* Hmm, I can't put translateY more than ~ 3 000 000. Maybe need to figure this out) */\n    const tableStyle = {\n        transform: `translateY(${virtualTopOffset}px)`,\n        tableLayout: fixedLayout ? \"fixed\" : undefined\n    };\n\n    return (\n        <table className=\"af-react-table-tbody-table\" aria-rowcount={totalRows} style={tableStyle}>\n            {CachedColgroup}\n            <tbody ref={tbodyRef}>\n                <Rows\n                    getRowData={getRowData}\n                    getRowKey={getRowKey}\n                    getRowExtraProps={getRowExtraProps}\n                    RowComponent={RowComponent}\n                    CellComponent={CellComponent}\n                />\n            </tbody>\n        </table>\n    );\n});\n\nexport default Table;","import React, { memo, useEffect, useCallback } from \"react\";\nimport useResizeObserver from \"use-resize-observer\";\nimport Table from \"./Table\";\nimport { useApiPlugin } from \"../useApi\";\n\nconst SUBSCRIBE_EVENTS = [\n    \"widget-scroll-height-changed\",\n    \"is-scrolling-changed\"\n];\n\nconst TableBody = memo(({\n    tbodyRef,\n    scrollContainerRef,\n    getRowData,\n    getRowKey,\n    getRowExtraProps,\n    RowComponent,\n    CellComponent,\n    fixedLayout,\n}) => {\n\n    const API = useApiPlugin( SUBSCRIBE_EVENTS );\n\n    const { width, height, ref } = useResizeObserver();\n\n    useEffect(() => {\n        API.setWidgetHeight( height ).setWidgetWidth( width );\n    }, [ height, width ]);\n\n\n    const scrollHandler = useCallback( e => {\n        const { scrollTop, scrollLeft } = e.target;\n        API.setScrollTop( scrollTop ).setScrollLeft( scrollLeft );\n    }, []);\n\n    const scrollWrapperStyle = {\n        width,\n        height\n    };\n\n    const heightProviderStyle = {\n        pointerEvents: API.isScrolling ? \"none\" : \"auto\",\n        height: API.widgetScrollHeight,\n        maxHeight: API.widgetScrollHeight\n    };\n    \n    /*\n        tabIndex=\"0\" is for proper keyboard nav\n    */\n    return (\n        <div className=\"af-react-table-tbody-wrapper\" ref={ref}>\n            <div tabIndex=\"0\" className=\"af-react-table-overflow-container\" style={scrollWrapperStyle} ref={scrollContainerRef} onScroll={scrollHandler}>\n                <div style={heightProviderStyle}>\n                    <Table\n                        tbodyRef={tbodyRef}\n                        getRowData={getRowData}\n                        getRowKey={getRowKey}\n                        getRowExtraProps={getRowExtraProps}\n                        RowComponent={RowComponent}\n                        CellComponent={CellComponent}\n                        fixedLayout={fixedLayout}\n                    />\n                </div>\n            </div>\n        </div>\n    );\n});\n\nexport default TableBody;","import React, { memo } from \"react\";\nimport { useApiPlugin } from \"../../useApi\";\n\nconst SUBSCRIBE_EVENTS = [\n    \"columns-changed\"\n];\n\nconst Colgroup = () => {\n    const { columns } = useApiPlugin( SUBSCRIBE_EVENTS );\n    return (\n        <colgroup>\n            {columns.map(({ dataKey, background, visibility, border }) => visibility !== \"hidden\" ? (\n                <col\n                    key={dataKey}\n                    style={{\n                        background,\n                        border\n                    }}\n                />\n            ) : null )}\n        </colgroup>\n    );\n};\n\nexport default memo( Colgroup );","import React, { memo } from \"react\";\nimport { useApiPlugin } from \"../useApi\";\nimport Colgroup from \"./Colgroup\";\n\nconst SUBSCRIBE_EVENTS = [\n    \"columns-changed\",\n    \"scroll-left-changed\",\n    \"column-widths-changed\",\n];\n\nconst CachedColgroup = <Colgroup />;\n\nconst TableHead = memo(() => {\n\n    const { columns, scrollLeft, tbodyColumnWidths } = useApiPlugin( SUBSCRIBE_EVENTS );\n\n    return (\n        <table className=\"af-react-table-thead-table\" style={{ right: scrollLeft }}>\n            {CachedColgroup}\n            <thead>\n                <tr>\n                    {columns.map(( column, j, cols ) => {\n                        if( column.visibility === \"hidden\" ){\n                            return null;\n                        }\n                        const width = tbodyColumnWidths[ j ];\n                        const style = j + 1 < cols.length ? { minWidth: width, width, maxWidth: width } : { minWidth: width };\n                        return (\n                            <th key={column.dataKey} style={style} title={column.title}>\n                                {column.label}\n                            </th>\n                        );\n                    })}\n                </tr>\n            </thead>\n        </table>\n    );\n});\n\nexport default TableHead;","const areArraysEqual = (one, two) => {\n\tif (one.length === two.length) {\n\t\tfor (let j = 0; j < one.length; j += 1) {\n\t\t\tif (two[j] !== one[j]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n};\n\nexport default areArraysEqual;\n","import camelCase from \"lodash/camelCase\";\nimport kebabCase from \"lodash/kebabCase\";\n\nconst addSetters = ( target, setters ) => {\n    for( let varName of setters ){\n        const setterName = camelCase( `set-${varName}` );\n        const eventName = kebabCase( `${varName}-changed` );\n        target[ setterName ] = function( newValue ){\n            const prevValue = this[ varName ];\n            if( newValue !== prevValue ){\n                this[ varName ] = newValue;\n                this.Events.emit( eventName, prevValue );\n            }\n            return this;\n        };\n    }\n};\n\nexport default addSetters;","/*\n    This constant is used for 2 reasons:\n        * Math.log2( 1 ) is 0, which is not correct for cache size calculation\n        * We should always have some extra space for new rows. We do not want to reallocate cache every time.\n*/\nconst MIN_TREE_CACHE_SIZE = 32;\n\nexport const walkUntil = ( dist, tree ) => {\n    const N = tree[ 0 ];\n\n    let nodeIndex = 1;\n\n    for( let v; nodeIndex < N; ){\n        v = tree[ nodeIndex <<= 1 ];\n        if( dist >= v ){\n            dist -= v;\n            nodeIndex |= 1;\n        }\n    }\n\n    return [ nodeIndex - N, dist ];\n};\n\nexport const sum = ( l, r, tree ) => {  \n    let res = 0; \n    const N = tree[ 0 ];\n    for( l += N, r += N; l < r; l >>= 1, r >>= 1 ){\n        if( l & 1 ){\n            res += tree[ l++ ];\n        }\n\n        if( r & 1 ){\n            res += tree[ --r ]; \n        }\n    };\n\n    return res; \n};\n\n/*\n    TODO:\n        this can be optimized even more\n*/\nexport const calculateParentsAt = ( posSet, tree ) => {\n    for( let pos of posSet ){\n        for( let i = pos, curSum; i > 1; ){\n            curSum = tree[ i ] + tree[ i ^ 1 ];\n            tree[ i >>= 1 ] = curSum;\n        }\n    }\n};\n\n/*\n    We always do batch insert, so there is no sense to update all parents each time.\n    It is more logical to call updateNodeAt many times, and then call calculateParentsAtPos once.\n*/\nexport const updateNodeAt = ( pos, value, tree ) => {\n    const N = tree[ 0 ];\n    pos += N;\n    if( tree[ pos ] !== value ){\n        tree[ pos ] = value;\n        return pos | 1;\n    }\n    return 0;\n};\n\nexport const getSize = elementsQuantity => 2 ** Math.ceil( Math.log2( elementsQuantity + MIN_TREE_CACHE_SIZE ) );\n\nconst calculateAllParents = ( tree, endIndex ) => {\n    for( let i = tree[ 0 ] + endIndex >> 1, j; i > 0; --i ){\n        j = i << 1;\n        tree[ i ] = tree[ j ] + tree[ j | 1 ];\n    }\n};\n\nconst getTreeContainer = endIndex => {\n    const N = getSize( endIndex );\n    const tree = new Uint32Array( N * 2 );\n    tree[ 0 ] = N;\n\n    return tree;\n};\n\nexport const getTree = ( endIndex, defaultValue ) => {\n    const tree = getTreeContainer( endIndex );\n    const N = tree[ 0 ];\n\n    tree.fill( defaultValue, N, endIndex + N );\n    calculateAllParents( tree, endIndex );\n    return tree;\n};\n\n/*\n    TODO:\n        think about reducing cache size( now it only increases )\n*/\nexport const reallocateIfNeeded = ( tree, prevEndIndex, endIndex, defaultValue ) => {\n\n    let N = tree[ 0 ];\n\n    if( endIndex > prevEndIndex ){\n        if( endIndex > N ){\n            const newTree = getTreeContainer( endIndex );\n            const newN = newTree[ 0 ];\n    \n            for( let idx = 0; idx < prevEndIndex; idx++ ){\n                newTree[ newN + idx ] = tree[ N + idx ];\n            }\n            \n            tree = newTree;\n            N = newN;\n        }\n    }\n    else{\n        endIndex ^= prevEndIndex;\n        prevEndIndex ^= endIndex;\n        endIndex ^= prevEndIndex;\n        defaultValue = 0;\n    }\n\n    tree.fill( defaultValue, N + prevEndIndex, N + endIndex );\n    calculateAllParents( tree, endIndex );\n    return tree;\n};","import EventEmitter from \"eventemitter3\";\nimport throttle from \"lodash/throttle\";\nimport debounce from \"lodash/debounce\";\nimport clamp from \"lodash/clamp\";\nimport addSetters from \"../../utils/addSetters\";\n\nimport {\n    updateNodeAt,\n    calculateParentsAt,\n    walkUntil,\n    getTree,\n    sum,\n    reallocateIfNeeded\n} from \"./treeUtils\";\n\nconst DEFAULT_ESTIMATED_ROW_HEIGHT = 30;\nconst ROW_MEASUREMENT_THROTTLING_INTERVAL = 300;\nconst IS_SCROLLING_DEBOUNCE_INTERVAL = 150;\nconst END_INDEX_CHECK_INTERVAL = 400;\n\nclass Base {\n\n    Events = new EventEmitter();\n\n    totalRows = 0;\n    startIndex = 0;\n    endIndex = 0;\n\n    virtualTopOffset = 0;\n    widgetScrollHeight = 0;\n\n    overscanRowsDistance = 0;\n    estimatedRowHeight = 0;\n\n    scrollTop = 0;\n    widgetHeight = 0;\n    widgetWidth = 0;\n\n    /*\n        Used to set pointer-events: none when scrolling\n    */\n    isScrolling = false;\n\n    heighsCache = null;\n\n    /*\n        Used to improve perf of segments tree and recalculate needed parents only once\n    */\n    updatedNodesSet = new Set();\n\n    setInitialScrollingEvents(){\n        this.Events\n            .off( \"scroll-top-changed\", this.setIsScrollingFalseDebounced )\n            .once( \"scroll-top-changed\", this.setIsScrollingTrue, this );\n        return this;\n    }\n\n    setIsScrollingTrue(){\n        this.isScrolling = true;\n        this.Events\n            .on( \"scroll-top-changed\", this.setIsScrollingFalseDebounced )\n            .emit( \"is-scrolling-changed\" );\n    }\n    \n    setIsScrollingFalseDebounced = debounce(() => {\n        this.isScrolling = false;\n        this.setInitialScrollingEvents()\n            .Events.emit( \"is-scrolling-changed\" );\n    }, IS_SCROLLING_DEBOUNCE_INTERVAL );\n\n    updateWidgetScrollHeight(){\n        /* In segments tree 1 node is always sum of all elements */\n        return this.setWidgetScrollHeight( this.heighsCache[ 1 ] );\n    }\n\n    /*\n        TODO: maybe some react-like performUnitOfWork logic is needed here?\n    */\n    setVisibleRowsHeights = throttle(() => {\n        const node = this.getRowsContainerNode();\n\n        if( node ){\n            for( let child of node.children ){\n                const newHeight = child.offsetHeight;\n                /*\n                    We can't rely on this.startIndex and this.endIndex here, because react updates DOM asynchronously\n                    and current rendered rows range may differ from startIndex - endIndex, especially if there are many rows and this method is throttled.\n                */\n                if( process.env.NODE_ENV !== \"production\" && !child.hasAttribute( \"aria-rowindex\" ) ){\n                    throw new Error( \"aria-rowindex attribute must be present on each row. Look at default Row implementations.\" );\n                }\n                const index = +child.getAttribute( \"aria-rowindex\" );\n                const tmpPos = updateNodeAt( index, newHeight, this.heighsCache );\n                if( tmpPos ){\n                    this.updatedNodesSet.add( tmpPos );\n                }\n            }\n\n            if( this.updatedNodesSet.size ){\n                calculateParentsAt( this.updatedNodesSet, this.heighsCache );\n                this.updatedNodesSet.clear();\n                this.updateWidgetScrollHeight();\n            }\n        }\n\n        return this;\n    }, ROW_MEASUREMENT_THROTTLING_INTERVAL );\n\n    /*\n        Column widths && heights may change during scroll/width-change,\n        especially if table layout is not fixed.\n    */\n    increaseEndIndexIfNeeded = debounce(() => {\n        const currentVisibleDist = sum( this.startIndex, this.endIndex, this.heighsCache );\n        if( this.widgetHeight > this.virtualTopOffset + currentVisibleDist - this.scrollTop ){\n            this.updateEndIndex();\n        }\n        return this;\n    }, END_INDEX_CHECK_INTERVAL );\n\n    cancelPendingAsyncCalls(){\n        this.setIsScrollingFalseDebounced.cancel();\n        this.setVisibleRowsHeights.cancel();\n        this.increaseEndIndexIfNeeded.cancel();\n        return this;\n    }\n\n    refreshOffsets(){\n        const dist = Math.max( 0, this.scrollTop - this.overscanRowsDistance );\n        const [ newStartIndex, remainder ] = walkUntil( dist, this.heighsCache );\n        \n        /*\n            TODO: maybe do not call setStartIndex and updateEndIndex, if newStartIndex === this.startIndex?\n        */\n        return this\n            .setVirtualTopOffset( dist - remainder )\n            .setStartIndex( newStartIndex )\n            .updateEndIndex();\n    }\n\n    updateEndIndex(){\n        const [ newEndIndex ] = walkUntil( this.scrollTop + this.widgetHeight + this.overscanRowsDistance, this.heighsCache );\n        /*\n            walkUntil works by \"strict less\" algo. It is good for startIndex,\n            but for endIndex we need \"<=\", so adding 1 artificially.\n        */\n        return this.setEndIndex( Math.min( newEndIndex + 1, this.totalRows ) );\n    }\n\n    toggleBasicEvents( method ){\n        this.Events\n            [ method ]( \"scroll-top-changed\", this.refreshOffsets, this )\n            [ method ]( \"overscan-rows-distance-changed\", this.refreshOffsets, this )\n            [ method ]( \"widget-scroll-height-changed\", this.increaseEndIndexIfNeeded )\n            [ method ]( \"widget-height-changed\", this.updateEndIndex, this )\n            [ method ]( \"rows-rendered\", this.setVisibleRowsHeights )\n            [ method ]( \"end-index-changed\", this.increaseEndIndexIfNeeded.cancel )\n            [ method ]( \"widget-width-changed\", this.setVisibleRowsHeights );\n        return this;\n    }\n\n    refreshHeightsCache( prevTotalRows ){\n        if( this.totalRows > 0 ){\n            if( prevTotalRows > 0 ){\n                this.heighsCache = reallocateIfNeeded( this.heighsCache, prevTotalRows, this.totalRows, this.estimatedRowHeight );\n                this.updateWidgetScrollHeight();\n            }\n            else{\n                this.heighsCache = getTree( this.totalRows, this.estimatedRowHeight );\n                this.toggleBasicEvents( \"on\" );\n            }\n        }\n        else{\n            this\n                .cancelPendingAsyncCalls()\n                .toggleBasicEvents( \"off\" );\n            this.startIndex = this.endIndex = this.virtualTopOffset = this.scrollTop = 0;\n        }\n    }\n\n    constructor( params ){\n        this.getRowsContainerNode = params.getRowsContainerNode;\n        this.getScrollContainerNode = params.getScrollContainerNode;\n        \n        this.Events.on( \"total-rows-changed\", this.refreshHeightsCache, this );\n\n        this\n            .setInitialScrollingEvents()\n            .setEstimatedRowHeight( params.estimatedRowHeight || DEFAULT_ESTIMATED_ROW_HEIGHT )\n            .setOverscanRowsDistance( params.overscanRowsDistance || 0 )\n            .setTotalRows( params.totalRows || 0 );\n    }\n\n    destructor(){\n        this\n            .cancelPendingAsyncCalls()\n            .Events.removeAllListeners();\n    }\n    \n    reportRowsRendered(){\n        this.Events.emit( \"rows-rendered\" );\n    }\n\n    /*\n        TODO: think, why this shit has ~20px fault\n    */\n    scrollToRow( index ){\n        const node = this.getScrollContainerNode();\n        if( node ){\n            index = clamp( index, 0, this.totalRows );\n            node.scrollTop = sum( 0, index, this.heighsCache );\n        }\n        return this;    \n    }\n}\n\naddSetters( Base.prototype, [\n    \"estimatedRowHeight\",\n    \"virtualTopOffset\",\n    \"scrollTop\",\n    \"widgetWidth\",\n    \"widgetHeight\",\n    \"widgetScrollHeight\",\n    \"overscanRowsDistance\",\n    \"startIndex\",\n    \"endIndex\",\n    \"totalRows\"\n]);\n\nexport default Base;","import throttle from \"lodash/throttle\";\nimport areArraysEqual from \"../../utils/areArraysEqual\";\nimport addSetters from \"../../utils/addSetters\";\nimport Basic from \"../Basic\";\n\nconst ROW_WIDTH_MEASUREMENT_INTERVAL = 100;\n\nclass Table extends Basic {\n\n    scrollLeft = 0;\n\n    columns = [];\n    tbodyColumnWidths = [];\n\n    calculateTbodyColumnWidths = throttle(() => {\n        const node = this.getRowsContainerNode();\n        if( node ){\n            for( let child of node.children ){\n                const tds = child.children;\n                if( tds.length === this.columns.length ){\n                    /* we must select \"correct\" rows without colspans, etc. */\n                    const pixelWidths = [];\n                    for( let td of tds ){\n                        pixelWidths.push( td.offsetWidth );\n                    }\n                    if( !areArraysEqual( this.tbodyColumnWidths, pixelWidths ) ){\n                        this.tbodyColumnWidths = pixelWidths;\n                        this.Events.emit( \"column-widths-changed\" );\n                    }\n                    break;\n                }\n            }\n        }\n    }, ROW_WIDTH_MEASUREMENT_INTERVAL );\n\n    constructor( params ){\n        super( params );\n        this.columns = params.columns || [];\n        this.tbodyColumnWidths.length = this.columns.length;\n        this.tbodyColumnWidths.fill( 0, 0, this.columns.length );\n\n        this.Events\n            .on( \"rows-rendered\", this.calculateTbodyColumnWidths )\n            .on( \"columns-changed\", this.calculateTbodyColumnWidths )\n            .on( \"widget-width-changed\", this.calculateTbodyColumnWidths );\n    }\n\n    destructor(){\n        this.calculateTbodyColumnWidths.cancel();\n        super.destructor();\n    }\n}\n\naddSetters( Table.prototype, [\n    \"columns\",\n    \"scrollLeft\"\n]);\n\nexport default Table;","function classNames( arg ){\n    for( let j = 1, len = arguments.length, className; j < len; j++ ){\n        className = arguments[ j ];\n        if( className ){\n            arg += ` ${className}`;\n        }\n    }\n    return arg;\n}\n\nexport default classNames;","import React from \"react\";\nimport PropTypes from \"prop-types\";\n\nconst Row = ({ columns, CellComponent, getRowData, getRowExtraProps, rowIndex }) => {\n\n    const rowData = getRowData( rowIndex );\n    const extraProps = getRowExtraProps && getRowExtraProps( rowData, rowIndex );\n\n    return (\n        <tr {...extraProps} aria-rowindex={rowIndex}>\n            {columns.map( column => column.visibility !== \"hidden\" ? (\n                <CellComponent\n                    key={column.dataKey}\n                    rowData={rowData}\n                    rowIndex={rowIndex}\n                    column={column}\n                />\n            ) : null )}\n        </tr>\n    );\n};\n\nRow.propTypes = {\n    columns: PropTypes.array.isRequired,\n    CellComponent: PropTypes.oneOfType([ PropTypes.func, PropTypes.node ]).isRequired,\n    getRowData: PropTypes.func.isRequired,\n    rowIndex: PropTypes.number.isRequired,\n    getRowExtraProps: PropTypes.func\n};\n\nexport default Row;","import React from \"react\";\nimport PropTypes from \"prop-types\";\n\n/*\n    If all cells in a row would be completely empty - row can \"collapse\" short.\n    To prevent it we can fill it with &nbsp;\n*/\nconst DEFAULT_EMPTY_CELL_CONTENT = \"\\u00A0\";\n\nconst Cell = ({ rowData, rowIndex, column }) => {\n    const { transformCellData, getEmptyCellData, dataKey } = column;\n\n    let cellData = rowData && rowData[ dataKey ];\n    \n    if( cellData === undefined || cellData === \"\" ){\n        cellData = getEmptyCellData ? getEmptyCellData( rowIndex, column ) : DEFAULT_EMPTY_CELL_CONTENT;\n    }\n    else if( transformCellData ){\n        cellData = transformCellData( cellData, rowData, column, rowIndex );\n    }\n\n    return (\n        <td key={dataKey}>\n            {cellData}\n        </td>\n    );\n};\n\nCell.propTypes = {\n    rowIndex: PropTypes.number.isRequired,\n    column: PropTypes.object.isRequired,\n    rowData: PropTypes.object\n};\n\nexport default Cell;","import React from \"react\";\nimport { css } from \"@emotion/core\";\n\nconst RowCountWarningContainer = props => <div className=\"af-react-table-default-warning-container\" {...props} />;\n\nexport default RowCountWarningContainer;","import React, { memo } from \"react\";\nimport PropTypes from \"prop-types\";\n\nimport Context from \"./Context\";\nimport TableBody from \"./TableBody\";\nimport TableHead from \"./TableHead\";\nimport VirtualTableDataStore from \"./models/Table\";\nimport cn from \"./utils/classNames\";\n\nimport RowComponentDefault from \"./defaultComponents/Row\";\nimport CellComponentDefault from \"./defaultComponents/Cell\";\nimport RowCountWarningContainerDefault from \"./defaultComponents/RowCountWarningContainer\";\n\n/*\n    If we provide a ref to a class component, we could access Data and call it's methods from outside( Data.scrollTo(), etc. ).\n    Functional components encapsulate internals, so to keep this flexibility we use class components here.\n*/\nclass Table extends React.PureComponent {\n\n    scrollContainerRef = React.createRef();\n    tbodyRef = React.createRef();\n\n    constructor( props ){\n        super( props );\n\n        this.Data = new VirtualTableDataStore({\n            overscanRowsDistance: props.overscanRowsDistance,\n            columns: props.columns,\n            totalRows: props.rowCount,\n            estimatedRowHeight: props.estimatedRowHeight,\n            getRowsContainerNode: () => this.tbodyRef.current,\n            getScrollContainerNode: () => this.scrollContainerRef.current\n        });\n    }\n    \n    componentDidUpdate(){\n        const { rowCount, columns, estimatedRowHeight, overscanRowsDistance } = this.props;\n        this.Data\n            .setOverscanRowsDistance( overscanRowsDistance )\n            .setColumns( columns )\n            .setTotalRows( rowCount )\n            .setEstimatedRowHeight( estimatedRowHeight );        \n    }\n\n    componentWillUnmount(){\n        this.Data.destructor();\n    }\n\n    render(){\n\n        const {\n            columns,\n            getRowData,\n            getRowKey,\n            getRowExtraProps,\n            rowCount,\n            estimatedRowHeight,\n            overscanRowsDistance,\n            rowCountWarningsTable,\n            fixedLayout,\n\n            RowComponent,\n            CellComponent,\n            RowCountWarningContainer,\n            className,\n\n            ...props\n        } = this.props;\n\n        return (\n            <Context.Provider value={this.Data}>\n                <div className={cn(\"af-react-table\", className )} {...props}>\n                    <TableHead />\n                    { rowCount > 0 ? (\n                        <TableBody\n                            scrollContainerRef={this.scrollContainerRef}\n                            tbodyRef={this.tbodyRef}\n                            getRowData={getRowData}\n                            getRowKey={getRowKey}\n                            getRowExtraProps={getRowExtraProps}\n                            RowComponent={RowComponent}\n                            CellComponent={CellComponent}\n                            fixedLayout={fixedLayout}\n                        />\n                    ) : rowCountWarningsTable ? (\n                        <RowCountWarningContainer>\n                            {rowCountWarningsTable[rowCount]}\n                        </RowCountWarningContainer>\n                    ) : null }\n                </div>\n            </Context.Provider>\n        );\n    };\n}\n\nTable.propTypes = {\n    columns: PropTypes.array.isRequired,\n    getRowData: PropTypes.func.isRequired,\n\n    rowCount: PropTypes.number,\n    getRowKey: PropTypes.func,\n    estimatedRowHeight: PropTypes.number,\n    getRowExtraProps: PropTypes.func,\n\n    /* as row heights may be different, we measure overscan in px */\n    overscanRowsDistance: PropTypes.number,\n\n    HeaderRowComponent: PropTypes.any,\n    RowComponent: PropTypes.any,\n    CellComponent: PropTypes.any,\n\n    RowCountWarningContainer: PropTypes.any,\n    rowCountWarningsTable: PropTypes.object,\n    fixedLayout: PropTypes.bool\n};\n\nTable.defaultProps = {\n    rowCount: 0,\n    estimatedRowHeight: 20,\n    overscanRowsDistance: 200,\n    fixedLayout: false,\n\n    /*\n        For 90% non-reactive solutions, which only provide new getRowData when data is changed, memo is ok.\n        If RowComponent should be wrapped my mobx observer - non-memo version should be imported.\n        memo(observer(RowComponentDefault)) will do the trick.\n    */\n    RowComponent: memo( RowComponentDefault ),\n    CellComponent: CellComponentDefault,\n    RowCountWarningContainer: RowCountWarningContainerDefault,\n};\n\nexport default Table;"],"sourceRoot":""}