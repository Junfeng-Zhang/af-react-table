{"version":3,"sources":["webpack:///./src/Context/index.js","webpack:///./src/useApi/index.js","webpack:///./src/TableBody/Table/Colgroup/index.js","webpack:///./src/TableBody/Table/Rows/index.js","webpack:///./src/TableBody/Table/index.js","webpack:///./src/TableBody/index.js","webpack:///./src/TableHead/Colgroup/index.js","webpack:///./src/TableHead/index.js","webpack:///./src/utils/areArraysEqual/index.js","webpack:///./src/utils/addSetters/index.js","webpack:///./src/models/Basic/treeUtils/index.js","webpack:///./src/models/Basic/index.js","webpack:///./src/models/Table/index.js","webpack:///./src/defaultComponents/Row/index.js","webpack:///./src/defaultComponents/Cell/index.js","webpack:///./src/defaultComponents/RowCountWarningContainer/index.js","webpack:///./src/index.js"],"names":["React","createContext","emptyArr","reducer","x","useApiPlugin","subscribeEvents","API","useContext","Context","ApiEvents","up","useReducer","useLayoutEffect","e","on","off","useApiPluginRaw","Events","SUBSCRIBE_EVENTS","memo","columns","map","dataKey","background","visibility","border","width","key","style","Rows","getRowData","getRowKey","getRowExtraProps","RowComponent","CellComponent","useEffect","reportRowsRendered","rangeFrom","rangeTo","rowKey","result","push","rowIndex","getVisibleRows","startIndex","endIndex","tableClass","CachedColgroup","Table","tbodyRef","fixedLayout","virtualTopOffset","totalRows","tableStyle","transform","tableLayout","undefined","className","aria-rowcount","ref","wrapperClass","overflowWrapperClass","TableBody","scrollContainerRef","useResizeObserver","height","setWidgetHeight","setWidgetWidth","scrollHandler","useCallback","target","scrollTop","scrollLeft","setScrollTop","setScrollLeft","scrollWrapperStyle","heightProviderStyle","pointerEvents","isScrolling","widgetScrollHeight","maxHeight","tabIndex","onScroll","TableHead","tbodyColumnWidths","right","column","j","cols","length","minWidth","maxWidth","title","label","areArraysEqual","one","two","addSetters","setters","varName","setterName","camelCase","eventName","kebabCase","newValue","prevValue","this","emit","walkUntil","dist","tree","v","N","nodeIndex","sum","l","r","res","calculateAllParents","i","getTreeContainer","elementsQuantity","Math","ceil","log2","Uint32Array","Base","params","EventEmitter","overscanRowsDistance","estimatedRowHeight","widgetHeight","widgetWidth","heighsCache","updatedNodesSet","Set","setIsScrollingFalseDebounced","debounce","setInitialScrollingEvents","setVisibleRowsHeights","throttle","pos","value","node","getRowsContainerNode","children","child","newHeight","offsetHeight","process","index","getAttribute","tmpPos","add","size","posSet","curSum","calculateParentsAt","clear","updateWidgetScrollHeight","increaseEndIndexIfNeeded","currentVisibleDist","updateEndIndex","getScrollContainerNode","refreshHeightsCache","setEstimatedRowHeight","setOverscanRowsDistance","setTotalRows","once","setIsScrollingTrue","setWidgetScrollHeight","cancelPendingAsyncCalls","cancel","refreshOffsets","max","newStartIndex","remainder","setVirtualTopOffset","setStartIndex","newEndIndex","setEndIndex","min","toggleBasicEvents","method","prevTotalRows","defaultValue","prevEndIndex","newTree","newN","idx","fill","reallocateIfNeeded","destructor","removeAllListeners","scrollToRow","clamp","prototype","calculateTbodyColumnWidths","tds","pixelWidths","td","offsetWidth","Row","rowData","extraProps","aria-rowindex","propTypes","PropTypes","array","isRequired","oneOfType","func","number","Cell","transformCellData","getEmptyCellData","cellData","object","RowCountWarningContainer","props","createRef","Data","VirtualTableDataStore","rowCount","current","componentDidUpdate","setColumns","componentWillUnmount","render","rowCountWarningsTable","Provider","PureComponent","HeaderRowComponent","any","bool","defaultProps","RowComponentDefault","CellComponentDefault","RowCountWarningContainerDefault"],"mappings":"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","file":"afReactTable.js","sourcesContent":["import React from \"react\";\n\nexport default React.createContext();","import { useContext, useLayoutEffect, useReducer } from \"react\";\nimport Context from \"../Context\";\n\nconst emptyArr = [];\n\nconst reducer = x => x + 1;\n\n/*\n\tTODO:\n\t\twhy useEffect does not properly update colgroup of tbody, when rowcount changes from 0 to positive value?\n*/\n\nconst useApiPluginRaw = ( ApiEvents, subscribeEvents) => {\n\n    const [, up] = useReducer( reducer, 0 );\n    \n\tuseLayoutEffect(() => {\n\t\tfor (let e of subscribeEvents) {\n\t\t\tApiEvents.on(e, up);\n\t\t}\n\t\treturn () => {\n\t\t\tfor (let e of subscribeEvents) {\n\t\t\t\tApiEvents.off(e, up);\n\t\t\t}\n\t\t};\n\t}, emptyArr );\n};\n\nexport const useApiContext = () => useContext( Context );\n\nexport const useApiPlugin = subscribeEvents => {\n\tconst API = useApiContext();\n    useApiPluginRaw( API.Events, subscribeEvents );\n    return API;\n};\n","import React, { memo } from \"react\";\nimport { useApiPlugin } from \"../../../useApi\";\n\nconst SUBSCRIBE_EVENTS = [\n    \"columns-changed\"\n];\n\nconst Colgroup = () => {\n    const { columns } = useApiPlugin( SUBSCRIBE_EVENTS );\n    return (\n        <colgroup>\n            {columns.map(({ dataKey, background, visibility, border, width }) => visibility !== \"hidden\" ? (\n                <col\n                    key={dataKey}\n                    style={{\n                        width,\n                        background,\n                        border\n                    }}\n                />\n            ) : null )}\n        </colgroup>\n    );\n};\n\nexport default memo( Colgroup );","import React, { memo, useEffect } from \"react\";\nimport { useApiPlugin } from \"../../../useApi\";\n\nconst SUBSCRIBE_EVENTS = [\n    \"start-index-changed\",\n    \"end-index-changed\",\n    \"columns-changed\"\n];\n\n\nconst getVisibleRows = (\n    rangeFrom,\n    rangeTo,\n    columns,\n    getRowData,\n    getRowKey,\n    getRowExtraProps,\n    RowComponent,\n    CellComponent\n) => {\n    const result = [];\n    for( let rowKey; rangeFrom < rangeTo; rangeFrom++ ){\n        rowKey = getRowKey ? getRowKey( rangeFrom ) : rangeFrom;\n        result.push(\n            <RowComponent\n                getRowExtraProps={getRowExtraProps}\n                rowIndex={rangeFrom}\n                key={rowKey}\n                columns={columns}\n                getRowData={getRowData}\n                CellComponent={CellComponent}\n            />\n        );\n    }\n    return result;\n};\n\nconst Rows = memo(({ getRowData, getRowKey, getRowExtraProps, RowComponent, CellComponent }) => {\n\n    const API = useApiPlugin( SUBSCRIBE_EVENTS );\n\n    useEffect(() => {\n        API.reportRowsRendered();\n    });\n\n    return getVisibleRows(\n        API.startIndex,\n        API.endIndex,\n        API.columns,\n        getRowData,\n        getRowKey,\n        getRowExtraProps,\n        RowComponent,\n        CellComponent\n    );\n});\n\nexport default Rows;","import React, { memo } from \"react\";\nimport { css } from \"emotion\";\nimport Colgroup from \"./Colgroup\";\nimport Rows from \"./Rows\";\nimport { useApiPlugin } from \"../../useApi\";\n\nconst SUBSCRIBE_EVENTS = [\n    \"virtual-top-offset-changed\",\n    \"total-rows-changed\"\n];\n\nconst tableClass = css`\n    contain: paint;\n    width: 100%;\n    will-change: transform;\n    table-layout: auto;\n`;\n\nconst CachedColgroup = <Colgroup />;\n\nconst Table = memo(({\n    getRowData,\n    getRowKey,\n    getRowExtraProps,\n    tbodyRef,\n    RowComponent,\n    CellComponent,\n    fixedLayout\n}) => {\n    const { virtualTopOffset, totalRows } = useApiPlugin( SUBSCRIBE_EVENTS );\n\n\n    /* Hmm, I can't put translateY more than ~ 3 000 000. Maybe need to figure this out) */\n    const tableStyle = {\n        transform: `translateY(${virtualTopOffset}px)`,\n        tableLayout: fixedLayout ? \"fixed\" : undefined\n    };\n\n    return (\n        <table className={tableClass} aria-rowcount={totalRows} style={tableStyle}>\n            {CachedColgroup}\n            <tbody ref={tbodyRef}>\n                <Rows\n                    getRowData={getRowData}\n                    getRowKey={getRowKey}\n                    getRowExtraProps={getRowExtraProps}\n                    RowComponent={RowComponent}\n                    CellComponent={CellComponent}\n                />\n            </tbody>\n        </table>\n    );\n});\n\nexport default Table;","import React, { memo, useEffect, useCallback } from \"react\";\nimport { css } from \"emotion\";\nimport useResizeObserver from \"use-resize-observer\";\nimport Table from \"./Table\";\nimport { useApiPlugin } from \"../useApi\";\n\nconst wrapperClass = css`\n    min-height: 0;\n    flex: 1 1 auto;\n    position: relative;\n    overflow: hidden;\n`;\n\nconst overflowWrapperClass = css`\n    overflow: auto;\n    position: absolute;\n    top: 0;\n    left: 0;\n`;\n\nconst SUBSCRIBE_EVENTS = [\n    \"widget-scroll-height-changed\",\n    \"is-scrolling-changed\"\n];\n\nconst TableBody = memo(({\n    tbodyRef,\n    scrollContainerRef,\n    getRowData,\n    getRowKey,\n    getRowExtraProps,\n    RowComponent,\n    CellComponent,\n    fixedLayout,\n}) => {\n\n    const API = useApiPlugin( SUBSCRIBE_EVENTS );\n\n    const { width, height, ref } = useResizeObserver();\n\n    useEffect(() => {\n        API.setWidgetHeight( height ).setWidgetWidth( width );\n    }, [ height, width ]);\n\n\n    const scrollHandler = useCallback( e => {\n        const { scrollTop, scrollLeft } = e.target;\n        API.setScrollTop( scrollTop ).setScrollLeft( scrollLeft );\n    }, []);\n\n    const scrollWrapperStyle = {\n        width,\n        height\n    };\n\n    const heightProviderStyle = {\n        pointerEvents: API.isScrolling ? \"none\" : \"auto\",\n        height: API.widgetScrollHeight,\n        maxHeight: API.widgetScrollHeight\n    };\n    \n    /*\n        tabIndex=\"0\" is for proper keyboard nav\n    */\n    return (\n        <div className={wrapperClass} ref={ref}>\n            <div tabIndex=\"0\" className={overflowWrapperClass} style={scrollWrapperStyle} ref={scrollContainerRef} onScroll={scrollHandler}>\n                <div style={heightProviderStyle}>\n                    <Table\n                        tbodyRef={tbodyRef}\n                        getRowData={getRowData}\n                        getRowKey={getRowKey}\n                        getRowExtraProps={getRowExtraProps}\n                        RowComponent={RowComponent}\n                        CellComponent={CellComponent}\n                        fixedLayout={fixedLayout}\n                    />\n                </div>\n            </div>\n        </div>\n    );\n});\n\nexport default TableBody;","import React, { memo } from \"react\";\nimport { useApiPlugin } from \"../../useApi\";\n\nconst SUBSCRIBE_EVENTS = [\n    \"columns-changed\"\n];\n\nconst Colgroup = () => {\n    const { columns } = useApiPlugin( SUBSCRIBE_EVENTS );\n    return (\n        <colgroup>\n            {columns.map(({ dataKey, background, visibility, border }) => visibility !== \"hidden\" ? (\n                <col\n                    key={dataKey}\n                    style={{\n                        background,\n                        border\n                    }}\n                />\n            ) : null )}\n        </colgroup>\n    );\n};\n\nexport default memo( Colgroup );","import React, { memo } from \"react\";\nimport { css } from \"emotion\";\nimport { useApiPlugin } from \"../useApi\";\nimport Colgroup from \"./Colgroup\";\n\nconst SUBSCRIBE_EVENTS = [\n    \"columns-changed\",\n    \"scroll-left-changed\",\n    \"column-widths-changed\",\n];\n\nconst CachedColgroup = <Colgroup />;\n\nconst wrapperClass = css`\n    flex: 0 0 auto;\n    min-width: 100%;\n    position: relative;\n    table-layout: fixed;\n\n    th {\n        text-overflow: ellipsis;\n        overflow: hidden;\n    }\n`;\n\n\nconst TableHead = memo(() => {\n\n    const { columns, scrollLeft, tbodyColumnWidths } = useApiPlugin( SUBSCRIBE_EVENTS );\n\n    return (\n        <table className={wrapperClass} style={{ right: scrollLeft }}>\n            {CachedColgroup}\n            <thead>\n                <tr>\n                    {columns.map(( column, j, cols ) => {\n                        if( column.visibility === \"hidden\" ){\n                            return null;\n                        }\n                        const width = tbodyColumnWidths[ j ];\n                        const style = j + 1 < cols.length ? { minWidth: width, width, maxWidth: width } : { minWidth: width };\n                        return (\n                            <th key={column.dataKey} style={style} title={column.title}>\n                                {column.label}\n                            </th>\n                        );\n                    })}\n                </tr>\n            </thead>\n        </table>\n    );\n});\n\nexport default TableHead;","const areArraysEqual = (one, two) => {\n\tif (one.length === two.length) {\n\t\tfor (let j = 0; j < one.length; j += 1) {\n\t\t\tif (two[j] !== one[j]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n};\n\nexport default areArraysEqual;\n","import camelCase from \"lodash/camelCase\";\nimport kebabCase from \"lodash/kebabCase\";\n\nconst addSetters = ( target, setters ) => {\n    for( let varName of setters ){\n        const setterName = camelCase( `set-${varName}` );\n        const eventName = kebabCase( `${varName}-changed` );\n        target[ setterName ] = function( newValue ){\n            const prevValue = this[ varName ];\n            if( newValue !== prevValue ){\n                this[ varName ] = newValue;\n                this.Events.emit( eventName, prevValue );\n            }\n            return this;\n        };\n    }\n};\n\nexport default addSetters;","/*\n    This constant is used for 2 reasons:\n        * Math.log2( 1 ) is 0, which is not correct for cache size calculation\n        * We should always have some extra space for new rows. We do not want to reallocate cache every time.\n*/\nconst MIN_TREE_CACHE_SIZE = 32;\n\nexport const walkUntil = ( dist, tree ) => {\n    const N = tree[ 0 ];\n\n    let nodeIndex = 1;\n\n    for( let v; nodeIndex < N; ){\n        v = tree[ nodeIndex <<= 1 ];\n        if( dist >= v ){\n            dist -= v;\n            nodeIndex |= 1;\n        }\n    }\n\n    return [ nodeIndex - N, dist ];\n};\n\nexport const sum = ( l, r, tree ) => {  \n    let res = 0; \n    const N = tree[ 0 ];\n    for( l += N, r += N; l < r; l >>= 1, r >>= 1 ){\n        if( l & 1 ){\n            res += tree[ l++ ];\n        }\n\n        if( r & 1 ){\n            res += tree[ --r ]; \n        }\n    };\n\n    return res; \n};\n\n/*\n    TODO:\n        this can be optimized even more\n*/\nexport const calculateParentsAt = ( posSet, tree ) => {\n    for( let pos of posSet ){\n        for( let i = pos, curSum; i > 1; ){\n            curSum = tree[ i ] + tree[ i ^ 1 ];\n            tree[ i >>= 1 ] = curSum;\n        }\n    }\n};\n\n/*\n    We always do batch insert, so there is no sense to update all parents each time.\n    It is more logical to call updateNodeAt many times, and then call calculateParentsAtPos once.\n*/\nexport const updateNodeAt = ( pos, value, tree ) => {\n    const N = tree[ 0 ];\n    pos += N;\n    if( tree[ pos ] !== value ){\n        tree[ pos ] = value;\n        return pos | 1;\n    }\n    return 0;\n};\n\nexport const getSize = elementsQuantity => 2 ** Math.ceil( Math.log2( elementsQuantity + MIN_TREE_CACHE_SIZE ) );\n\nconst calculateAllParents = ( tree, endIndex ) => {\n    for( let i = tree[ 0 ] + endIndex >> 1, j; i > 0; --i ){\n        j = i << 1;\n        tree[ i ] = tree[ j ] + tree[ j | 1 ];\n    }\n};\n\nconst getTreeContainer = endIndex => {\n    const N = getSize( endIndex );\n    const tree = new Uint32Array( N * 2 );\n    tree[ 0 ] = N;\n\n    return tree;\n};\n\nexport const getTree = ( endIndex, defaultValue ) => {\n    const tree = getTreeContainer( endIndex );\n    const N = tree[ 0 ];\n\n    tree.fill( defaultValue, N, endIndex + N );\n    calculateAllParents( tree, endIndex );\n    return tree;\n};\n\n/*\n    TODO:\n        think about reducing cache size( now it only increases )\n*/\nexport const reallocateIfNeeded = ( tree, prevEndIndex, endIndex, defaultValue ) => {\n\n    let N = tree[ 0 ];\n\n    if( endIndex > prevEndIndex ){\n        if( endIndex > N ){\n            const newTree = getTreeContainer( endIndex );\n            const newN = newTree[ 0 ];\n    \n            for( let idx = 0; idx < prevEndIndex; idx++ ){\n                newTree[ newN + idx ] = tree[ N + idx ];\n            }\n            \n            tree = newTree;\n            N = newN;\n        }\n    }\n    else{\n        endIndex ^= prevEndIndex;\n        prevEndIndex ^= endIndex;\n        endIndex ^= prevEndIndex;\n        defaultValue = 0;\n    }\n\n    tree.fill( defaultValue, N + prevEndIndex, N + endIndex );\n    calculateAllParents( tree, endIndex );\n    return tree;\n};","import EventEmitter from \"eventemitter3\";\nimport throttle from \"lodash/throttle\";\nimport debounce from \"lodash/debounce\";\nimport clamp from \"lodash/clamp\";\nimport addSetters from \"../../utils/addSetters\";\n\nimport {\n    updateNodeAt,\n    calculateParentsAt,\n    walkUntil,\n    getTree,\n    sum,\n    reallocateIfNeeded\n} from \"./treeUtils\";\n\nconst DEFAULT_ESTIMATED_ROW_HEIGHT = 30;\nconst ROW_MEASUREMENT_THROTTLING_INTERVAL = 300;\nconst IS_SCROLLING_DEBOUNCE_INTERVAL = 150;\nconst END_INDEX_CHECK_INTERVAL = 400;\n\nclass Base {\n\n    Events = new EventEmitter();\n\n    totalRows = 0;\n    startIndex = 0;\n    endIndex = 0;\n\n    virtualTopOffset = 0;\n    widgetScrollHeight = 0;\n\n    overscanRowsDistance = 0;\n    estimatedRowHeight = 0;\n\n    scrollTop = 0;\n    widgetHeight = 0;\n    widgetWidth = 0;\n\n    /*\n        Used to set pointer-events: none when scrolling\n    */\n    isScrolling = false;\n\n    heighsCache = null;\n\n    /*\n        Used to improve perf of segments tree and recalculate needed parents only once\n    */\n    updatedNodesSet = new Set();\n\n    setInitialScrollingEvents(){\n        this.Events\n            .off( \"scroll-top-changed\", this.setIsScrollingFalseDebounced )\n            .once( \"scroll-top-changed\", this.setIsScrollingTrue, this );\n        return this;\n    }\n\n    setIsScrollingTrue(){\n        this.isScrolling = true;\n        this.Events\n            .on( \"scroll-top-changed\", this.setIsScrollingFalseDebounced )\n            .emit( \"is-scrolling-changed\" );\n    }\n    \n    setIsScrollingFalseDebounced = debounce(() => {\n        this.isScrolling = false;\n        this.setInitialScrollingEvents()\n            .Events.emit( \"is-scrolling-changed\" );\n    }, IS_SCROLLING_DEBOUNCE_INTERVAL );\n\n    updateWidgetScrollHeight(){\n        /* In segments tree 1 node is always sum of all elements */\n        return this.setWidgetScrollHeight( this.heighsCache[ 1 ] );\n    }\n\n    /*\n        TODO: maybe some react-like performUnitOfWork logic is needed here?\n    */\n    setVisibleRowsHeights = throttle(() => {\n        const node = this.getRowsContainerNode();\n\n        if( node ){\n            for( let child of node.children ){\n                const newHeight = child.offsetHeight;\n                /*\n                    We can't rely on this.startIndex and this.endIndex here, because react updates DOM asynchronously\n                    and current rendered rows range may differ from startIndex - endIndex, especially if there are many rows and this method is throttled.\n                */\n                if( process.env.NODE_ENV !== \"production\" && !child.hasAttribute( \"aria-rowindex\" ) ){\n                    throw new Error( \"aria-rowindex attribute must be present on each row. Look at default Row implementations.\" );\n                }\n                const index = +child.getAttribute( \"aria-rowindex\" );\n                const tmpPos = updateNodeAt( index, newHeight, this.heighsCache );\n                if( tmpPos ){\n                    this.updatedNodesSet.add( tmpPos );\n                }\n            }\n\n            if( this.updatedNodesSet.size ){\n                calculateParentsAt( this.updatedNodesSet, this.heighsCache );\n                this.updatedNodesSet.clear();\n                this.updateWidgetScrollHeight();\n            }\n        }\n\n        return this;\n    }, ROW_MEASUREMENT_THROTTLING_INTERVAL );\n\n    /*\n        Column widths && heights may change during scroll/width-change,\n        especially if table layout is not fixed.\n    */\n    increaseEndIndexIfNeeded = debounce(() => {\n        const currentVisibleDist = sum( this.startIndex, this.endIndex, this.heighsCache );\n        if( this.widgetHeight > this.virtualTopOffset + currentVisibleDist - this.scrollTop ){\n            this.updateEndIndex();\n        }\n        return this;\n    }, END_INDEX_CHECK_INTERVAL );\n\n    cancelPendingAsyncCalls(){\n        this.setIsScrollingFalseDebounced.cancel();\n        this.setVisibleRowsHeights.cancel();\n        this.increaseEndIndexIfNeeded.cancel();\n        return this;\n    }\n\n    refreshOffsets(){\n        const dist = Math.max( 0, this.scrollTop - this.overscanRowsDistance );\n        const [ newStartIndex, remainder ] = walkUntil( dist, this.heighsCache );\n        \n        /*\n            TODO: maybe do not call setStartIndex and updateEndIndex, if newStartIndex === this.startIndex?\n        */\n        return this\n            .setVirtualTopOffset( dist - remainder )\n            .setStartIndex( newStartIndex )\n            .updateEndIndex();\n    }\n\n    updateEndIndex(){\n        const [ newEndIndex ] = walkUntil( this.scrollTop + this.widgetHeight + this.overscanRowsDistance, this.heighsCache );\n        /*\n            walkUntil works by \"strict less\" algo. It is good for startIndex,\n            but for endIndex we need \"<=\", so adding 1 artificially.\n        */\n        return this.setEndIndex( Math.min( newEndIndex + 1, this.totalRows ) );\n    }\n\n    toggleBasicEvents( method ){\n        this.Events\n            [ method ]( \"scroll-top-changed\", this.refreshOffsets, this )\n            [ method ]( \"overscan-rows-distance-changed\", this.refreshOffsets, this )\n            [ method ]( \"widget-scroll-height-changed\", this.increaseEndIndexIfNeeded )\n            [ method ]( \"widget-height-changed\", this.updateEndIndex, this )\n            [ method ]( \"rows-rendered\", this.setVisibleRowsHeights )\n            [ method ]( \"end-index-changed\", this.increaseEndIndexIfNeeded.cancel )\n            [ method ]( \"widget-width-changed\", this.setVisibleRowsHeights );\n        return this;\n    }\n\n    refreshHeightsCache( prevTotalRows ){\n        if( this.totalRows > 0 ){\n            if( prevTotalRows > 0 ){\n                this.heighsCache = reallocateIfNeeded( this.heighsCache, prevTotalRows, this.totalRows, this.estimatedRowHeight );\n                this.updateWidgetScrollHeight();\n            }\n            else{\n                this.heighsCache = getTree( this.totalRows, this.estimatedRowHeight );\n                this.toggleBasicEvents( \"on\" );\n            }\n        }\n        else{\n            this\n                .cancelPendingAsyncCalls()\n                .toggleBasicEvents( \"off\" );\n            this.startIndex = this.endIndex = this.virtualTopOffset = this.scrollTop = 0;\n        }\n    }\n\n    constructor( params ){\n        this.getRowsContainerNode = params.getRowsContainerNode;\n        this.getScrollContainerNode = params.getScrollContainerNode;\n        \n        this.Events.on( \"total-rows-changed\", this.refreshHeightsCache, this );\n\n        this\n            .setInitialScrollingEvents()\n            .setEstimatedRowHeight( params.estimatedRowHeight || DEFAULT_ESTIMATED_ROW_HEIGHT )\n            .setOverscanRowsDistance( params.overscanRowsDistance || 0 )\n            .setTotalRows( params.totalRows || 0 );\n    }\n\n    destructor(){\n        this\n            .cancelPendingAsyncCalls()\n            .Events.removeAllListeners();\n    }\n    \n    reportRowsRendered(){\n        this.Events.emit( \"rows-rendered\" );\n    }\n\n    /*\n        TODO: think, why this shit has ~20px fault\n    */\n    scrollToRow( index ){\n        const node = this.getScrollContainerNode();\n        if( node ){\n            index = clamp( index, 0, this.totalRows );\n            node.scrollTop = sum( 0, index, this.heighsCache );\n        }\n        return this;    \n    }\n}\n\naddSetters( Base.prototype, [\n    \"estimatedRowHeight\",\n    \"virtualTopOffset\",\n    \"scrollTop\",\n    \"widgetWidth\",\n    \"widgetHeight\",\n    \"widgetScrollHeight\",\n    \"overscanRowsDistance\",\n    \"startIndex\",\n    \"endIndex\",\n    \"totalRows\"\n]);\n\nexport default Base;","import throttle from \"lodash/throttle\";\nimport areArraysEqual from \"../../utils/areArraysEqual\";\nimport addSetters from \"../../utils/addSetters\";\nimport Basic from \"../Basic\";\n\nconst ROW_WIDTH_MEASUREMENT_INTERVAL = 100;\n\nclass Table extends Basic {\n\n    scrollLeft = 0;\n\n    columns = [];\n    tbodyColumnWidths = [];\n\n    calculateTbodyColumnWidths = throttle(() => {\n        const node = this.getRowsContainerNode();\n        if( node ){\n            for( let child of node.children ){\n                const tds = child.children;\n                if( tds.length === this.columns.length ){\n                    /* we must select \"correct\" rows without colspans, etc. */\n                    const pixelWidths = [];\n                    for( let td of tds ){\n                        pixelWidths.push( td.offsetWidth );\n                    }\n                    if( !areArraysEqual( this.tbodyColumnWidths, pixelWidths ) ){\n                        this.tbodyColumnWidths = pixelWidths;\n                        this.Events.emit( \"column-widths-changed\" );\n                    }\n                    break;\n                }\n            }\n        }\n    }, ROW_WIDTH_MEASUREMENT_INTERVAL );\n\n    constructor( params ){\n        super( params );\n        this.columns = params.columns || [];\n        this.tbodyColumnWidths.length = this.columns.length;\n        this.tbodyColumnWidths.fill( 0, 0, this.columns.length );\n\n        this.Events\n            .on( \"rows-rendered\", this.calculateTbodyColumnWidths )\n            .on( \"columns-changed\", this.calculateTbodyColumnWidths )\n            .on( \"widget-width-changed\", this.calculateTbodyColumnWidths );\n    }\n\n    destructor(){\n        this.calculateTbodyColumnWidths.cancel();\n        super.destructor();\n    }\n}\n\naddSetters( Table.prototype, [\n    \"columns\",\n    \"scrollLeft\"\n]);\n\nexport default Table;","import React from \"react\";\nimport PropTypes from \"prop-types\";\n\nconst Row = ({ columns, CellComponent, getRowData, getRowExtraProps, rowIndex }) => {\n\n    const rowData = getRowData( rowIndex );\n    const extraProps = getRowExtraProps && getRowExtraProps( rowData, rowIndex );\n\n    return (\n        <tr {...extraProps} aria-rowindex={rowIndex}>\n            {columns.map( column => column.visibility !== \"hidden\" ? (\n                <CellComponent\n                    key={column.dataKey}\n                    rowData={rowData}\n                    rowIndex={rowIndex}\n                    column={column}\n                />\n            ) : null )}\n        </tr>\n    );\n};\n\nRow.propTypes = {\n    columns: PropTypes.array.isRequired,\n    CellComponent: PropTypes.oneOfType([ PropTypes.func, PropTypes.node ]).isRequired,\n    getRowData: PropTypes.func.isRequired,\n    rowIndex: PropTypes.number.isRequired,\n    getRowExtraProps: PropTypes.func\n};\n\nexport default Row;","import React from \"react\";\nimport PropTypes from \"prop-types\";\n\n/*\n    If all cells in a row would be completely empty - row can \"collapse\" short.\n    To prevent it we can fill it with &nbsp;\n*/\nconst DEFAULT_EMPTY_CELL_CONTENT = \"\\u00A0\";\n\nconst Cell = ({ rowData, rowIndex, column }) => {\n    const { transformCellData, getEmptyCellData, dataKey } = column;\n\n    let cellData = rowData && rowData[ dataKey ];\n    \n    if( cellData === undefined || cellData === \"\" ){\n        cellData = getEmptyCellData ? getEmptyCellData( rowIndex, column ) : DEFAULT_EMPTY_CELL_CONTENT;\n    }\n    else if( transformCellData ){\n        cellData = transformCellData( cellData, rowData, column, rowIndex );\n    }\n\n    return (\n        <td key={dataKey}>\n            {cellData}\n        </td>\n    );\n};\n\nCell.propTypes = {\n    rowIndex: PropTypes.number.isRequired,\n    column: PropTypes.object.isRequired,\n    rowData: PropTypes.object\n};\n\nexport default Cell;","import React from \"react\";\nimport { css, cx } from \"emotion\";\n\nconst wrapperClass = css`\n    flex: 1 1 auto;\n    overflow: hidden;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n`;\n\nconst RowCountWarningContainer = ({ className, ...props }) => <div className={cx(wrapperClass,className)} {...props} />;\n\nexport default RowCountWarningContainer;","import React, { memo } from \"react\";\nimport PropTypes from \"prop-types\";\nimport { css, cx } from \"emotion\";\n\nimport Context from \"./Context\";\nimport TableBody from \"./TableBody\";\nimport TableHead from \"./TableHead\";\nimport VirtualTableDataStore from \"./models/Table\";\n\nimport RowComponentDefault from \"./defaultComponents/Row\";\nimport CellComponentDefault from \"./defaultComponents/Cell\";\nimport RowCountWarningContainerDefault from \"./defaultComponents/RowCountWarningContainer\";\n\n\n/*\n    * flex: 1 1 auto, assuming that table would be used full-stretch mostly\n    * border-box is important, because head th widths are synced with td widths\n    width: 100% covers case, when no tbody is rendered and exact width cannot be calculated\n*/\nconst wrapperClass = css`\n    display: flex;\n    flex: 1 1 auto;\n    flex-flow: column nowrap;\n    overflow: hidden;\n\n    * {\n        box-sizing: border-box;\n    }\n`;\n\n/*\n    If we provide a ref to a class component, we could access Data and call it's methods from outside( Data.scrollTo(), etc. ).\n    Functional components encapsulate internals, so to keep this flexibility we use class components here.\n*/\nclass Table extends React.PureComponent {\n\n    scrollContainerRef = React.createRef();\n    tbodyRef = React.createRef();\n\n    constructor( props ){\n        super( props );\n\n        this.Data = new VirtualTableDataStore({\n            overscanRowsDistance: props.overscanRowsDistance,\n            columns: props.columns,\n            totalRows: props.rowCount,\n            estimatedRowHeight: props.estimatedRowHeight,\n            getRowsContainerNode: () => this.tbodyRef.current,\n            getScrollContainerNode: () => this.scrollContainerRef.current\n        });\n    }\n    \n    componentDidUpdate(){\n        const { rowCount, columns, estimatedRowHeight, overscanRowsDistance } = this.props;\n        this.Data\n            .setOverscanRowsDistance( overscanRowsDistance )\n            .setColumns( columns )\n            .setTotalRows( rowCount )\n            .setEstimatedRowHeight( estimatedRowHeight );        \n    }\n\n    componentWillUnmount(){\n        this.Data.destructor();\n    }\n\n    render(){\n\n        const {\n            columns,\n            getRowData,\n            getRowKey,\n            getRowExtraProps,\n            rowCount,\n            estimatedRowHeight,\n            overscanRowsDistance,\n            rowCountWarningsTable,\n            fixedLayout,\n\n            RowComponent,\n            CellComponent,\n            RowCountWarningContainer,\n            className,\n\n            ...props\n        } = this.props;\n\n        return (\n            <Context.Provider value={this.Data}>\n                <div className={cx(wrapperClass, className )} {...props}>\n                    <TableHead />\n                    { rowCount > 0 ? (\n                        <TableBody\n                            scrollContainerRef={this.scrollContainerRef}\n                            tbodyRef={this.tbodyRef}\n                            getRowData={getRowData}\n                            getRowKey={getRowKey}\n                            getRowExtraProps={getRowExtraProps}\n                            RowComponent={RowComponent}\n                            CellComponent={CellComponent}\n                            fixedLayout={fixedLayout}\n                        />\n                    ) : rowCountWarningsTable ? (\n                        <RowCountWarningContainer>\n                            {rowCountWarningsTable[rowCount]}\n                        </RowCountWarningContainer>\n                    ) : null }\n                </div>\n            </Context.Provider>\n        );\n    };\n}\n\nTable.propTypes = {\n    columns: PropTypes.array.isRequired,\n    getRowData: PropTypes.func.isRequired,\n\n    rowCount: PropTypes.number,\n    getRowKey: PropTypes.func,\n    estimatedRowHeight: PropTypes.number,\n    getRowExtraProps: PropTypes.func,\n\n    /* as row heights may be different, we measure overscan in px */\n    overscanRowsDistance: PropTypes.number,\n\n    HeaderRowComponent: PropTypes.any,\n    RowComponent: PropTypes.any,\n    CellComponent: PropTypes.any,\n\n    RowCountWarningContainer: PropTypes.any,\n    rowCountWarningsTable: PropTypes.object,\n    fixedLayout: PropTypes.bool\n};\n\nTable.defaultProps = {\n    rowCount: 0,\n    estimatedRowHeight: 20,\n    overscanRowsDistance: 200,\n    fixedLayout: false,\n\n    /*\n        For 90% non-reactive solutions, which only provide new getRowData when data is changed, memo is ok.\n        If RowComponent should be wrapped my mobx observer - non-memo version should be imported.\n        memo(observer(RowComponentDefault)) will do the trick.\n    */\n    RowComponent: memo( RowComponentDefault ),\n    CellComponent: CellComponentDefault,\n    RowCountWarningContainer: RowCountWarningContainerDefault,\n};\n\nexport default Table;"],"sourceRoot":""}